#include "memoryMap.h"

#ifndef CRC_VALUE
#  if defined( BOOT_SELECTOR )
#    include "crcValueBootS.h"
#  elif defined ( APP_SLOT1 )
#    include "crcValueAppSlot1.h"
#  elif defined ( APP_SLOT2 )
#    include "crcValueAppSlot2.h"
#  else
#    define CRC_VALUE 0xdeadbeef
#  endif
#endif

MEMORY
{
    FLASH_SOFTDEVICE (rx) : ORIGIN = NORDIC_SOFTDEVICE_ADR, LENGTH = NORDIC_SOFTDEVICE_LEN
    FLASH_READ (rx)       : ORIGIN = SW_FLASH_ADR, LENGTH = SW_FLASH_LEN
    RUN_STATS (rw)        : ORIGIN = RUN_STATS_ADR, LENGTH = RUN_STATS_LEN
    RAM (rw)              : ORIGIN = SW_RAM_ADR, LENGTH = SW_RAM_LEN
// #ifdef BUILD_AN_APP
    RAM_KEEP (rw)         : ORIGIN = RAM_KEEP_THROUGH_RESET_ADR, LENGTH = RAM_KEEP_THROUGH_RESET_LEN
    RAM_RESET_STACK(rw)   : ORIGIN = RAM_APP_RESET_STACK, LENGTH = RAM_APP_RESET_STACK_LEN
// #endif

    // TODO KJJ: We should clean this up, need to get the address from somewhere
    // See dfu_types.h
    /** Location of bootloader setting in flash. */
    BOOTLOADER_SETTINGS (rw) : ORIGIN = 0x0007D000, LENGTH = 0x1000

    // TODO KJJ: We should clean this up, need to get the address from somewhere
    // See dfu_types.h
    /** Location in UICR where bootloader start address is stored. */
    UICR_BOOTLOADER (r) : ORIGIN = 0x10001014, LENGTH = 0x04

    // TODO KJJ: We should clean this up, need to get the address from somewhere
    /** Location of mbr params page in flash. */
    MBR_PARAMS_PAGE (rw) : ORIGIN = 0x0007C000, LENGTH = 0x1000

    // TODO KJJ: We should clean this up, need to get the address from somewhere
    /** Location in UICR where mbr params page address is stored. */
    UICR_MBR_PARAM_PAGE(r) : ORIGIN = 0x10001018, LENGTH = 0x04
}

ENTRY(Reset_Handler)

/*
 * *** Notice! ***
 * _Min_Heap_Size is the heap size for newLib.
 * See include/FreeRTOSconfig.h to change the FreeRTOS heap.
 */
_Min_Heap_Size = 0x0;

SECTIONS
{
    .text :
    {
        _startIsrVector = .;
        //
        // Define an alias for _startIsrVector as __isr_vector for compatibility with nordic.nrf52sdk
        //
        __isr_vector = .;
        KEEP(*(.isr_vector))
        . = 0x200;
        *(.progHeader)
        *(.text*)
        *(.rodata*)
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)

        KEEP (*(.init))
        KEEP (*(.fini))

    } > FLASH_READ

    .ARM :
    {
        . = ALIGN(4);

        __exidx_start = .;
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
        __exidx_end = .;

    } > FLASH_READ

    . = ALIGN(4);

    /*
     * .data contains globals and statics with initial values that are copied
     * from ROM to RAM on startup.
     *
     * _startInitSourceData = where to start copying from
     * _endInitSourceData   = where to stop copying from
     */

    _startInitSourceData = .;

// #if defined( BUILD_AN_APP )
    /*
     * .run_stats is ram that we don't want to zero on reset.
     */
     .run_stats (NOLOAD) :
     {
         . = ALIGN(4);
         //
         // Define __data_start__ which is used to validate the RAM section set aside for the Nordic Softdevice.
         //
         __data_start__ = .;
         *(.run_stats)
     } > RUN_STATS
    /*
     * .ram_keep is ram that we don't want to zero on reset.
     */
     .ram_keep (NOLOAD) :
     {
         *(.ram_keep)
     } > RAM_KEEP
    /*
     * .ram_keep_2 is ram that we don't want to zero on reset.
     *
     * We place it after .ram_keep so that it does not cause the
     * items in .ram_keep to move.
     */
     .ram_keep_2 (NOLOAD) :
     {
         *(.ram_keep_2)
     } > RAM_KEEP
    /*
     * .reset_stack is ram that we don't want to zero on reset.
     */
     .reset_stack (NOLOAD) :
     {
         *(.reset_stack)
     } > RAM_RESET_STACK
// #endif

    .data : AT ( _startInitSourceData )
    {
        . = ALIGN(4);
        _startInitDestinationData = .;
        *(.data*)
        *(.ccm*)
        . = ALIGN(4);
        __start_fs_data = .;
        KEEP(*(.fs_data))
        __stop_fs_data = .;
#if defined(BOOT_SELECTOR)
        . = ALIGN(4);
        KEEP(*(.noinit))
#endif
        . = ALIGN(4);
        _endInitDestinationData = .;
        __data_end__ = .;

    } > RAM

#if defined(BOOT_SELECTOR)
    /* Ensures the bootloader settings are placed at the last flash page. */
    .bootloaderSettings (NOLOAD):
    {
        . = ALIGN(4);
        *(.bootloaderSettings*)

    } > BOOTLOADER_SETTINGS

    /* Ensures the Bootloader start address in flash is written to UICR when flashing the image. */
    .uicrBootStartAddress :
    {
        KEEP(*(.uicrBootStartAddress))
    } > UICR_BOOTLOADER

    /* Place the mbr params page in flash. */
    .mbrParamsPage (NOLOAD) :
    {

    } > MBR_PARAMS_PAGE

    /* Write the bootloader address in UICR. */
    .uicrMbrParamsPageAddress :
    {
        KEEP(*(.uicrMbrParamsPageAddress))
    } > UICR_MBR_PARAM_PAGE

#endif

    .bss (NOLOAD):
    {
        . = ALIGN(4);
        _startBss = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        _endBss = .;

    } > RAM

    /* Allocate user heap space for newlib _sbrk */
    ._newlib_heap (NOLOAD) :
    {
        . = ALIGN(4);
        end = . ;
        _heap_start = . ;
        . = . + _Min_Heap_Size;
        . = ALIGN(4);
        _heap_end = . ;

    } > RAM

    .crc _startInitSourceData + SIZEOF(.data) : {
        . = ALIGN(4);
        _crc_adr = .;
        LONG(CRC_VALUE);
    } > FLASH_READ
}
